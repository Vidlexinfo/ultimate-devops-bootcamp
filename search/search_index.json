{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Ultimate Devops  Bootcamp by School of Devops\n\n\nThis is a Lab Guide which goes along with the Ultimate Devops Bootcamp  Course by School of Devops. \n\n\nFor information about the devops trainign courses visit \nschoolofdevops.com\n.\n\n\nTeam\n\n\n\n\nGourav Shah", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-ultimate-devops-bootcamp-by-school-of-devops", 
            "text": "This is a Lab Guide which goes along with the Ultimate Devops Bootcamp  Course by School of Devops.   For information about the devops trainign courses visit  schoolofdevops.com .", 
            "title": "Welcome to Ultimate Devops  Bootcamp by School of Devops"
        }, 
        {
            "location": "/#team", 
            "text": "Gourav Shah", 
            "title": "Team"
        }, 
        {
            "location": "/preface/", 
            "text": "Preface\n\n\nThis is an example of \"frontmatter\", which comes before the main text of the book.\n\n\nCourse Outline\n\n\nChapter 01: Codifying Devops\n\n\n\n\nWhy Devops  \n\n\nHistory    \n\n\nPrinciples and Practices  \n\n\n\n\nChapter 02: Use Case Workshop\n\n\n\n\nDescription of Use Case\n\n\nOrganization Goals\n\n\nPain Points\n\n\nDiagnosing the issues\n\n\nSolution Design\n\n\n\n\nChapter 03: Git quick dive\n\n\n\n\nGit and Distributed Revision Control\n\n\nRepos\n\n\nBranching and Merging\n\n\nGithub\n\n\nBranching Strategy\n\n\nGit References\n\n\nLab\n\n\nSetting up repos\n\n\nCreate a devops repo  \n\n\n\n\n\n\n\n\nChapter 04: Ansible quick dive\n\n\n\n\nWhy Ansible\n\n\nIaaC\n\n\nConvergence\n\n\nIdempotence\n\n\nAnsible Concepts\n\n\nInventory\n\n\nPlaybooks\n\n\nRoles\n\n\nModules\n\n\nVars/Templates\n\n\n\n\n\n\n\n\nChapter 05: Creating Ansible code for Demo App\n\n\n\n\nPlaybooks for\n\n\nSystem Configurations\n\n\nApplication Configurations\n\n\nDeployment\n\n\n\n\n\n\nAdditional Code for Provisioning Automation\n\n\n\n\nChapter 06: Provisioning Automation\n\n\n\n\nVagrant\n\n\nLabs:\n\n\nCreate dev env\n\n\nIntegrate with Ansible\n\n\n\n\n\n\n\n\nChapter 07: Continous Integration\n\n\n\n\nTheory\n\n\n\n\nChapter 08: Setting up a CI Pipeline with Jenkins\n\n\n\n\nSetup Jenkins\n\n\nCommit Stage Jobs\n\n\nbuild/compile\n\n\nunit test\n\n\nstatic code analysis\n\n\n\n\n\n\nArtifacts Management\n\n\nFunctional Acceptance Testing\n\n\nDeploy to Staging\n\n\nNFR Testing\n\n\n\n\nChapter 09: Cloud and AWS* Cloud and Devop\n\n\n\n\nAWS\n\n\n\n\nChapter 10: Deploy a prod Environment on AWS\n\n\n\n\nDesign considerations\n\n\nAvailability\n\n\nScalability\n\n\nManageability\n\n\nSecurity  \n\n\n\n\n\n\nDeploy to prod, integrate with Jenkins\n\n\n\n\nChapter 11: Containers and Docker\n\n\n\n\nAdvantages of using containers\n\n\nPortability\n\n\nConsistency\n\n\nDensity\n\n\nEco System\n\n\nSpeed\n\n\n\n\n\n\nDocker quick dive\n\n\nRunning Containers\n\n\nOperating Containers\n\n\nPort Mapping\n\n\nBuilding Docker Images\n\n\n\n\n\n\n\n\nChapter 12:  Dockerizing App Stack\n\n\n\n\nBuild Dockerfiles\n\n\nCreate Docker Compose specs\n\n\n\n\nChapter 13: Kubernetes: Taking Containers to Production\n\n\n\n\nCOEs and intro to k8s\n\n\nk8s Quick Dive\n\n\nPods\n\n\ndeployments\n\n\nservices\n\n\nIngress\n\n\nrollouts\n\n\n\n\n\n\n\n\nChapter 14: Deploying Demo app in Production\n\n\n\n\nDeploy k8s Cluster /Minikube\n\n\nCreate k8s objects\n\n\ndeployment\n\n\nservice\n\n\ningress\n\n\n\n\n\n\nRelease Management\n\n\nZero Downtime\n\n\nBlue Green\n\n\nCanary\n\n\n\n\n\n\n\n\nChapter  15: Monitoring\n\n\n\n\nWhy Monitoring ?\n\n\nWhat to monitor\n\n\nLogs\n\n\nAPM\n\n\nHealth\n\n\n\n\n\n\nLabs:\n\n\nSetup log monitoring\n\n\nSetup performance monitoring\n\n\nHealth Monitoring and Alerting", 
            "title": "Outline"
        }, 
        {
            "location": "/preface/#preface", 
            "text": "This is an example of \"frontmatter\", which comes before the main text of the book.", 
            "title": "Preface"
        }, 
        {
            "location": "/preface/#course-outline", 
            "text": "Chapter 01: Codifying Devops   Why Devops    History      Principles and Practices     Chapter 02: Use Case Workshop   Description of Use Case  Organization Goals  Pain Points  Diagnosing the issues  Solution Design   Chapter 03: Git quick dive   Git and Distributed Revision Control  Repos  Branching and Merging  Github  Branching Strategy  Git References  Lab  Setting up repos  Create a devops repo       Chapter 04: Ansible quick dive   Why Ansible  IaaC  Convergence  Idempotence  Ansible Concepts  Inventory  Playbooks  Roles  Modules  Vars/Templates     Chapter 05: Creating Ansible code for Demo App   Playbooks for  System Configurations  Application Configurations  Deployment    Additional Code for Provisioning Automation   Chapter 06: Provisioning Automation   Vagrant  Labs:  Create dev env  Integrate with Ansible     Chapter 07: Continous Integration   Theory   Chapter 08: Setting up a CI Pipeline with Jenkins   Setup Jenkins  Commit Stage Jobs  build/compile  unit test  static code analysis    Artifacts Management  Functional Acceptance Testing  Deploy to Staging  NFR Testing   Chapter 09: Cloud and AWS* Cloud and Devop   AWS   Chapter 10: Deploy a prod Environment on AWS   Design considerations  Availability  Scalability  Manageability  Security      Deploy to prod, integrate with Jenkins   Chapter 11: Containers and Docker   Advantages of using containers  Portability  Consistency  Density  Eco System  Speed    Docker quick dive  Running Containers  Operating Containers  Port Mapping  Building Docker Images     Chapter 12:  Dockerizing App Stack   Build Dockerfiles  Create Docker Compose specs   Chapter 13: Kubernetes: Taking Containers to Production   COEs and intro to k8s  k8s Quick Dive  Pods  deployments  services  Ingress  rollouts     Chapter 14: Deploying Demo app in Production   Deploy k8s Cluster /Minikube  Create k8s objects  deployment  service  ingress    Release Management  Zero Downtime  Blue Green  Canary     Chapter  15: Monitoring   Why Monitoring ?  What to monitor  Logs  APM  Health    Labs:  Setup log monitoring  Setup performance monitoring  Health Monitoring and Alerting", 
            "title": "Course Outline"
        }, 
        {
            "location": "/ansible/", 
            "text": "ansible-galaxy install  -p roles geerlingguy.mysql", 
            "title": "Ansible"
        }, 
        {
            "location": "/020_install_jenkins_jfrog_artifactory/", 
            "text": "Jenkins\n\n\nJenkins is a essential automation tool to setup Continuous Integration. Its the integrator which helps you build your development,  testing and deployment  workflow and create job pipelines. It also adds visibility to all stake holders including the Dev, QA, Ops teams involved in building, testing and deploying the product.\n\n\nJFrog Artifactory\n\n\nJFrog Artifactory is the only Universal Repository Manager supporting all major packaging formats, build tools and CI servers. Shipping updates continuously and automatically has become a critical element of any successful operation.\n\n\nSetting up CI-CD Environment with Docker-Compose\n\n\nThis is the easiest method to setup Jenkins and is a recommended option.  \n\n\nInstalling Docker Engine and Docker-Compose\n\n\nProceed with installing Docker Engine and docker-compose on your choice of Operating System. For details on how to install docker visit the official installation page at\n\n\ndocker engine\n\n\ndocker-compose\n\n\nWe assume you have installed docker, docker-compose and are ready to launch containers before proceeding. To validate docker environment run.\n\n\ndocker ps\n\n\n\n\nIf the above command goes through without errors, you are all set.\n\n\nRunning Jenkins and Artifactory using Docker-Compose\n\n\nOnce you all set, now you can create compose file for Jenkins and Artifactory. This is the simplest way of installing Jenkins, Artifactory and requires minimal efforts.\n\n\ndocker-compose-CI-CD.yml\n\n\nversion: '2'\n\nnetworks:\n  custom:\n    driver: bridge\n    ipam:\n      driver: default\n      config:\n        - subnet: 192.168.61.0/28\nservices:\n  jenkins:\n    image: jenkins\n    ports:\n      - \n8080:8080\n\n      - \n50000:50000\n\n    volumes:\n      - \n/var/run/docker.sock:/var/run/docker.sock\n\n    networks:\n      custom:\n        ipv4_address: 192.168.61.4\n    domainname: codespaces.io\n    hostname: jenkins\n    restart: always\n  artifactory:\n    image: docker.bintray.io/jfrog/artifactory-oss\n    ports:\n      - \n8081:8081\n\n    networks:\n      custom:\n        ipv4_address: 192.168.61.5\n    domainname: codespaces.io\n    hostname: artifactory\n    restart: always\n\n\n\n\nOnce you are ready with compose file, run below command to make it running\n\n\ndocker-compose -f docker-compose-CI-CD.yml up -d\n\n\n\n\nIf you install it using the instructions above, find out the IP address and go to\nhttp://YOUR_IP_ADDRESS:8080 to access jenkins UI\nhttp://YOUR_IP_ADDRESS:8081 to access artifactory UI\n\n\nTo start/stop containers with docker, use the following commands,\n\n\ndocker start [container-id]\ndocker stop [container-id]\n\n\n\n\nCommon Post Installation Steps\n\n\nJenkins\n\n\nAfter the installation, you will be asked for password. The password will be saved in the following file.\n\n\n/var/jenkins_home/secrets/initialAdminPassword\n\n\n\n\nPassword can be also fetched from the logs. You could run the following command to view the password,\n\n\ndocker logs jenkins\n\n\n\n\nor to follow the logs\n\n\ndocker logs -f jenkins\n\n[use ^c to come back to the terminal]\n\n\n\n\n\n\nClick on  \nSelect Plugins to Install\n when given an option.\n\n\n\nThis will let you choose the plugins to install on the next page. On the selection page,\n  * Click on \nNone\n to deselect all plugins\n  \n\n\nCreate Admin user\n\n\n\n\nNow we have successfully installed Jenkins and we can proceed with configurations\n\n\nArtifactory\n\n\nDefault Credentials:\nusername : admin\npassword : password  \n\n\n\n\nAfter login in you will be welcomed with this page.\n\n\n\n\n\n\n\n\nClick on next, You will be asked to set up admin username and password. \nSkip\n this for now and use the default credentials.\n\n\n\n\n\n\nAfter that, you will be asked to \nConfigure a Proxy Server\n. \nSkip\n this step as well.\n\n\n\n\n\n\nIn \nCreate Repositories\n page, click on \nGeneric\n and \nmaven\n and click on \nCreate\n.\n\n\n\n\n\n\n\n\n\n\nThen click on \nfinish\n.", 
            "title": "Setting up CI-CD Environment"
        }, 
        {
            "location": "/020_install_jenkins_jfrog_artifactory/#jenkins", 
            "text": "Jenkins is a essential automation tool to setup Continuous Integration. Its the integrator which helps you build your development,  testing and deployment  workflow and create job pipelines. It also adds visibility to all stake holders including the Dev, QA, Ops teams involved in building, testing and deploying the product.", 
            "title": "Jenkins"
        }, 
        {
            "location": "/020_install_jenkins_jfrog_artifactory/#jfrog-artifactory", 
            "text": "JFrog Artifactory is the only Universal Repository Manager supporting all major packaging formats, build tools and CI servers. Shipping updates continuously and automatically has become a critical element of any successful operation.", 
            "title": "JFrog Artifactory"
        }, 
        {
            "location": "/020_install_jenkins_jfrog_artifactory/#setting-up-ci-cd-environment-with-docker-compose", 
            "text": "This is the easiest method to setup Jenkins and is a recommended option.", 
            "title": "Setting up CI-CD Environment with Docker-Compose"
        }, 
        {
            "location": "/020_install_jenkins_jfrog_artifactory/#installing-docker-engine-and-docker-compose", 
            "text": "Proceed with installing Docker Engine and docker-compose on your choice of Operating System. For details on how to install docker visit the official installation page at  docker engine  docker-compose  We assume you have installed docker, docker-compose and are ready to launch containers before proceeding. To validate docker environment run.  docker ps  If the above command goes through without errors, you are all set.", 
            "title": "Installing Docker Engine and Docker-Compose"
        }, 
        {
            "location": "/020_install_jenkins_jfrog_artifactory/#running-jenkins-and-artifactory-using-docker-compose", 
            "text": "Once you all set, now you can create compose file for Jenkins and Artifactory. This is the simplest way of installing Jenkins, Artifactory and requires minimal efforts.  docker-compose-CI-CD.yml  version: '2'\n\nnetworks:\n  custom:\n    driver: bridge\n    ipam:\n      driver: default\n      config:\n        - subnet: 192.168.61.0/28\nservices:\n  jenkins:\n    image: jenkins\n    ports:\n      -  8080:8080 \n      -  50000:50000 \n    volumes:\n      -  /var/run/docker.sock:/var/run/docker.sock \n    networks:\n      custom:\n        ipv4_address: 192.168.61.4\n    domainname: codespaces.io\n    hostname: jenkins\n    restart: always\n  artifactory:\n    image: docker.bintray.io/jfrog/artifactory-oss\n    ports:\n      -  8081:8081 \n    networks:\n      custom:\n        ipv4_address: 192.168.61.5\n    domainname: codespaces.io\n    hostname: artifactory\n    restart: always  Once you are ready with compose file, run below command to make it running  docker-compose -f docker-compose-CI-CD.yml up -d  If you install it using the instructions above, find out the IP address and go to\nhttp://YOUR_IP_ADDRESS:8080 to access jenkins UI\nhttp://YOUR_IP_ADDRESS:8081 to access artifactory UI  To start/stop containers with docker, use the following commands,  docker start [container-id]\ndocker stop [container-id]", 
            "title": "Running Jenkins and Artifactory using Docker-Compose"
        }, 
        {
            "location": "/020_install_jenkins_jfrog_artifactory/#common-post-installation-steps", 
            "text": "", 
            "title": "Common Post Installation Steps"
        }, 
        {
            "location": "/020_install_jenkins_jfrog_artifactory/#jenkins_1", 
            "text": "After the installation, you will be asked for password. The password will be saved in the following file.  /var/jenkins_home/secrets/initialAdminPassword  Password can be also fetched from the logs. You could run the following command to view the password,  docker logs jenkins  or to follow the logs  docker logs -f jenkins\n\n[use ^c to come back to the terminal]   Click on   Select Plugins to Install  when given an option.  This will let you choose the plugins to install on the next page. On the selection page,\n  * Click on  None  to deselect all plugins\n    Create Admin user   Now we have successfully installed Jenkins and we can proceed with configurations", 
            "title": "Jenkins"
        }, 
        {
            "location": "/020_install_jenkins_jfrog_artifactory/#artifactory", 
            "text": "Default Credentials:\nusername : admin\npassword : password    After login in you will be welcomed with this page.     Click on next, You will be asked to set up admin username and password.  Skip  this for now and use the default credentials.    After that, you will be asked to  Configure a Proxy Server .  Skip  this step as well.    In  Create Repositories  page, click on  Generic  and  maven  and click on  Create .      Then click on  finish .", 
            "title": "Artifactory"
        }, 
        {
            "location": "/030_install_plugins/", 
            "text": "Jenkins configurations\n\n\nGetting Familiar with Jenkins Console\n\n\nWhen you login to jenkins for the first time, following is the screen you would see.\n\n\n\n\n\nOn the left side of the screen, on top is the menu to  create new projects, to manage jenkins, to create users etc.\n\n\nJust below the menu is the build queue. All  jobs scheduled to run get added to the queue and would appear here.  \n\n\nBelow build queue is the build executor status. This shows the status of the jobs being executed in real time.\n\n\nBottom right of the page is the information about jenkins version displayed.\n\n\n\n\nConfiguring Global Security\n\n\n\n\nSelect  Manage Jenkins -\n Configure Global Security\n\n\nVerify\n\n\ncheckbox for \"Enable Security\" is checked\n\n\nFrom Security Realm,  \"Jenkins own database\" is selected\n\n\nAuthorization is set to \"Logged in users can do anything\"\n\n\n\n\nObserve the configs  and verify as per the screenshot attached below\n\n\n\n\nJenkins Plugins\n\n\nThe real magic of Jenkins lies in its rich plugins eco system. This is how tools integrate with jenkins to build a CI workflow. You want to trigger jenkins jobs after every change going into git, you have a plugin for it. You want to send a notification to your developers on a successful or failed builds, you have a notification plugin. You want to use a tool to fetch or push the build artifacts, you have a plugin for it. This is how most of the tools talk to jenkins.\n\n\nIn this tutorial, we are going to learn a simple process to install plugins. As part of this, we will end us installing a plugin which would help us integrate jenkins with our git repository.\n\n\nExploring Plugins Configurations\n\n\n\n\nFrom \"Manage Jenkins\", select  \"Manage Plugins\" option.  \n\n\nOn the Manage Plugins pane you would see the following tabs,\n\n\nUpdates\n\n\nAvailable\n\n\nInstalled\n\n\nAdvanced\n \n\n\n\n\nSelect \"Installed\" to view the list of the plugins which came pre installed with jenkins.\n\n\nInstalling Plugins\n\n\n\n\nFrom \"Manage Plugins\", select \nAvailable\n tab.\n\n\n\n\nOn the top-right corner you should see a filter box, start typing the search term in that box. we will need below plugins to be installed for our CI-CD setup.\n\n\n\n\n\n\nGit Plugin\n  \n\n\n\n\n\n\nWorkspace Cleanup Plugin\n  \n\n\n\n\n\n\nMaven Plugin\n  \n\n\n\n\n\n\nNodeJS Plugin\n  \n  \n\n\n\n\n\n\nGo Plugin\n  \n\n\n\n\n\n\nGit Tag Plugin\n  \n\n\n\n\n\n\nSsh Plugin\n  \n\n\n\n\n\n\nArtifactory Plugin", 
            "title": "Jenkins Global Security and Plugins Configurations"
        }, 
        {
            "location": "/030_install_plugins/#jenkins-configurations", 
            "text": "", 
            "title": "Jenkins configurations"
        }, 
        {
            "location": "/030_install_plugins/#getting-familiar-with-jenkins-console", 
            "text": "When you login to jenkins for the first time, following is the screen you would see.   On the left side of the screen, on top is the menu to  create new projects, to manage jenkins, to create users etc.  Just below the menu is the build queue. All  jobs scheduled to run get added to the queue and would appear here.    Below build queue is the build executor status. This shows the status of the jobs being executed in real time.  Bottom right of the page is the information about jenkins version displayed.", 
            "title": "Getting Familiar with Jenkins Console"
        }, 
        {
            "location": "/030_install_plugins/#configuring-global-security", 
            "text": "Select  Manage Jenkins -  Configure Global Security  Verify  checkbox for \"Enable Security\" is checked  From Security Realm,  \"Jenkins own database\" is selected  Authorization is set to \"Logged in users can do anything\"   Observe the configs  and verify as per the screenshot attached below", 
            "title": "Configuring Global Security"
        }, 
        {
            "location": "/030_install_plugins/#jenkins-plugins", 
            "text": "The real magic of Jenkins lies in its rich plugins eco system. This is how tools integrate with jenkins to build a CI workflow. You want to trigger jenkins jobs after every change going into git, you have a plugin for it. You want to send a notification to your developers on a successful or failed builds, you have a notification plugin. You want to use a tool to fetch or push the build artifacts, you have a plugin for it. This is how most of the tools talk to jenkins.  In this tutorial, we are going to learn a simple process to install plugins. As part of this, we will end us installing a plugin which would help us integrate jenkins with our git repository.", 
            "title": "Jenkins Plugins"
        }, 
        {
            "location": "/030_install_plugins/#exploring-plugins-configurations", 
            "text": "From \"Manage Jenkins\", select  \"Manage Plugins\" option.    On the Manage Plugins pane you would see the following tabs,  Updates  Available  Installed  Advanced\n    Select \"Installed\" to view the list of the plugins which came pre installed with jenkins.", 
            "title": "Exploring Plugins Configurations"
        }, 
        {
            "location": "/030_install_plugins/#installing-plugins", 
            "text": "From \"Manage Plugins\", select  Available  tab.   On the top-right corner you should see a filter box, start typing the search term in that box. we will need below plugins to be installed for our CI-CD setup.    Git Plugin\n      Workspace Cleanup Plugin\n      Maven Plugin\n      NodeJS Plugin\n         Go Plugin\n      Git Tag Plugin\n      Ssh Plugin\n      Artifactory Plugin", 
            "title": "Installing Plugins"
        }, 
        {
            "location": "/040_jenkins_config/", 
            "text": "Jenkins Tools configurations\n\n\nOnce you installed all plugins, we can go ahead to make required changes in configurations.\n\n\n\n\n\n\nConfiguring Maven\n\n\n\n\nGo to section Maven\n\n\nProvide name for maven installation\n\n\nSelect check box to install it automatically and select version to be installed.\n\n\n\n\n\nConfiguring NodeJS\n\n\n\n\nGo to section NodeJS\n\n\nProvide name for nodejs installation\n\n\nSelect check box to install it automatically and select version to be installed.\n\n\nYou can provide names to install global modules, which very common for all services.\n\n\n\n\n\nConfiguring Go\n\n\n\n\nGo to section Go\n\n\nProvide name for go installation\n\n\nSelect check box to install it automatically and select version to be installed.\n\n\n\n\n\nConfiguring SSH for remote host\n\n\n\n\nGo to section SSH remote hosts in \nConfigure Systems\n setting.\n\n\nProvide host name for hosts to ssh.\n\n\nSelect ssh port 22.\n\n\nWe need to provide credentials for same. We can create credentials in \nConfigure Credentials\n menu.\n\n\nSelect check box to install it automatically and select version to be installed.\n\n\n\n\n\nConfiguring Artifactory\n\n\n\n\nProvide the server id for Artifactory server.\n\n\nProvide URL of Artifactory server.\n\n\nProvide default credentials for Artifactory.\n\n\nonce you added credentials check the connectivity, it will provide Artifactory version \n(e.g 5.8.4)", 
            "title": "Jenkins Tools Configurations"
        }, 
        {
            "location": "/040_jenkins_config/#jenkins-tools-configurations", 
            "text": "Once you installed all plugins, we can go ahead to make required changes in configurations.", 
            "title": "Jenkins Tools configurations"
        }, 
        {
            "location": "/040_jenkins_config/#configuring-maven", 
            "text": "Go to section Maven  Provide name for maven installation  Select check box to install it automatically and select version to be installed.", 
            "title": "Configuring Maven"
        }, 
        {
            "location": "/040_jenkins_config/#configuring-nodejs", 
            "text": "Go to section NodeJS  Provide name for nodejs installation  Select check box to install it automatically and select version to be installed.  You can provide names to install global modules, which very common for all services.", 
            "title": "Configuring NodeJS"
        }, 
        {
            "location": "/040_jenkins_config/#configuring-go", 
            "text": "Go to section Go  Provide name for go installation  Select check box to install it automatically and select version to be installed.", 
            "title": "Configuring Go"
        }, 
        {
            "location": "/040_jenkins_config/#configuring-ssh-for-remote-host", 
            "text": "Go to section SSH remote hosts in  Configure Systems  setting.  Provide host name for hosts to ssh.  Select ssh port 22.  We need to provide credentials for same. We can create credentials in  Configure Credentials  menu.  Select check box to install it automatically and select version to be installed.", 
            "title": "Configuring SSH for remote host"
        }, 
        {
            "location": "/040_jenkins_config/#configuring-artifactory", 
            "text": "Provide the server id for Artifactory server.  Provide URL of Artifactory server.  Provide default credentials for Artifactory.  once you added credentials check the connectivity, it will provide Artifactory version  (e.g 5.8.4)", 
            "title": "Configuring Artifactory"
        }, 
        {
            "location": "/050_jenkins_jobs/", 
            "text": "Creating First Project\n\n\nIn this session we are going to create and launch our first project  with jenkins. We will be using a free style project for this example.\n\n\nTypes of Jobs\n\n\nWith Jenkins you could create following kind of projects or jobs.\n\n\n\n\nFree Style\n\n\nMaven\n\n\nExternal Job\n\n\nMulti Configuration\n\n\n\n\nJenkins Jobs Anatomy\n\n\nA typical style jenkins jobs has the following sections.\n\n\n\n\n\n\nName/description\n\n\nAdvanced Option\n\n\nSource Code Management\n\n\nBuild Triggers\n\n\nPre Build\n\n\nBuild\n\n\nPost Build\n\n\n\n\nCreating a Simple Job\n\n\nLets now create a simple job using jenkins to run a hello world program.\n\n\n\n\nFrom Jenkins Main page, click on \nNew Item\n.\n    \n  \n\n\nProvide a name to the project in Item Name i.e. \"job1\". Check against Free Style Project.\n    \n\n\n\n\nNext screen opens the job configuration page. On the job configuration page,\n\n\n\n\n\n\nAdd job description. e.g., \"Our first Jenkins Job\".\n\n\n\n\n\n\nSkip Source Code Management and Build Triggers, and scroll down to \nBuild\n configurations.\n\n\n\n\n\n\nFrom \"Add Build Step\" select \nExecute Shell\n and provide commands to execute. Since this  is a  mock job, you could provide following sample code,\n\n\n\n\n\n\n#!/bin/bash\necho \nHello World !\n\nsleep 10\n\n\n\n\nReview and click on save to go to project page.\n\n\n\n\nBuilding Job for the First Time\n\n\nClick on \nBuild Now\n to launch a build. Once the build is started, you would see the status in the \nBuild History\n section.\n\n\nOnce build is finished, click on the build number which starts with # . Clicking on the build number e.g. \n#1\n will take you to the page which shows the build stats. Option of interest on this page might be \nConsole Status\n which shows the run time output.", 
            "title": "Jenkins Jobs"
        }, 
        {
            "location": "/050_jenkins_jobs/#creating-first-project", 
            "text": "In this session we are going to create and launch our first project  with jenkins. We will be using a free style project for this example.", 
            "title": "Creating First Project"
        }, 
        {
            "location": "/050_jenkins_jobs/#types-of-jobs", 
            "text": "With Jenkins you could create following kind of projects or jobs.   Free Style  Maven  External Job  Multi Configuration", 
            "title": "Types of Jobs"
        }, 
        {
            "location": "/050_jenkins_jobs/#jenkins-jobs-anatomy", 
            "text": "A typical style jenkins jobs has the following sections.    Name/description  Advanced Option  Source Code Management  Build Triggers  Pre Build  Build  Post Build", 
            "title": "Jenkins Jobs Anatomy"
        }, 
        {
            "location": "/050_jenkins_jobs/#creating-a-simple-job", 
            "text": "Lets now create a simple job using jenkins to run a hello world program.   From Jenkins Main page, click on  New Item .\n         Provide a name to the project in Item Name i.e. \"job1\". Check against Free Style Project.\n       Next screen opens the job configuration page. On the job configuration page,    Add job description. e.g., \"Our first Jenkins Job\".    Skip Source Code Management and Build Triggers, and scroll down to  Build  configurations.    From \"Add Build Step\" select  Execute Shell  and provide commands to execute. Since this  is a  mock job, you could provide following sample code,    #!/bin/bash\necho  Hello World ! \nsleep 10  Review and click on save to go to project page.", 
            "title": "Creating a Simple Job"
        }, 
        {
            "location": "/050_jenkins_jobs/#building-job-for-the-first-time", 
            "text": "Click on  Build Now  to launch a build. Once the build is started, you would see the status in the  Build History  section.  Once build is finished, click on the build number which starts with # . Clicking on the build number e.g.  #1  will take you to the page which shows the build stats. Option of interest on this page might be  Console Status  which shows the run time output.", 
            "title": "Building Job for the First Time"
        }, 
        {
            "location": "/060_building_jobs_pipeline/", 
            "text": "Building Jobs Pipeline\n\n\nCreating More Jobs to add to pipeline\n\n\nLets create 2 more jobs so that we could connect those together to setup a mock build pipeline.\n\n\nTo create new jobs, you could click on create items, name the job and select the last option which says \nCopy from Another Job\n.\n\n\n\n\nFor this tutorial, lets create jobs by name \njob2\n and \njob3\n which should be copies of job1.\n\n\n\n\nAt the end of this exercise, you should see 3 jobs listed on jenkins dashboard as above. While creating Job2 and Job3 for the first time, do not use any build triggers. We will update the configurations while defining upstream/downstream.\n\n\nConnecting jobs\n\n\nLets now create a pipeline by connecting these jobs together. We would create a pipeline with\n\n\njob1 =\n job2 =\n job3\n\n\n\n\nWhere, job2 should run, only if job1 is built successfully, and should trigger job3 once it builds itself successfully. We could either define both  connections from job2, or go to job1 and job3 and define its relationship with job2.  We would do the later.\n\n\nLets open Job1 configurations and from \nPost Build Actions\n select \nBuild Other Projects\n and select \njob2\n.\n\n\n\n\nLets also go to jobs3 and define a dependency on job2. To do so, you would have to scroll to \nBuild Triggers\n section and select \nBuild after other projects are built\n and provide job2.\n\n\n\n\nUpstreams and Downstreams\n\n\nJenkins calls these connections as \nUpstreams\n and \nDownstreams\n. In the context of job1, its downstream is job2. And for job2, job1 is its upstream. Same goes with job2 and job3.  This is depicted in the following image which shows the job2 configurations.\n\n\n\n\nInstall Pipeline Plugin\n\n\nTo get a better view of the complete pipeline and the workflow, we would install a plugin which allows us to create a special view for connected jobs.\n\n\nTo install this plugin,\n\n\n\n\n\n\nFrom \nManage Jenkins\n select \nManage Plugins\n.\n\n\n\n\n\n\nClick on \nAvailable\n tab and start typing \"pipeline\" int he filter box. No need to press enter.\n\n\n\n\n\n\nCheck the box against \nBuild Pipeline Plugin\n, the second option, and click on the button at the bottom to \"Download and install after restart\".\n\n\n\n\n\n\nIf you don't see this plugin in the \nAvailable\n list then check the \nInstalled\n list to see if it is installed already.\n\n\n\n\n\n\n\n\nCrete Pipeline View\n\n\nLets now create a pipeline view.\n\n\n\n\nFrom Jenkins dashboard click on the \n+\n symbol besides the current list view named \nALL\n which displays all jobs.\n\n\n\n\n\n\n\n\nProvide a name to the view e.g. \npipe1\n, check the radio button for \nBuild Pipeline View\n. Click on ok.\n\n\n\n\n\n\n\n\nFrom the view configurations, select initial job from the drop down menu and the number of displayed builds.  Click on OK to finish configurations and show the view.\n\n\n\n\n\n\nRun pipelines\n\n\n\n\nThe pipeline view reads the first job, and picks up all the jobs which are directly or indirectly connected showing you one single view of the complete workflow and the order in which it is going to be executed.\n\n\n\n\n\n\n\n\n\n\nPipeline view also shows the history of job runs up to the number of instances you selected earlier in the configurations.\n\n\n\n\n\n\nGo trigger a \nRun\n from the pipeline view and see what happens. Make sure you have selected \"ENABLE AUTO REFRESH\" earlier from the top right corner of the screen.", 
            "title": "Building a Pipeline"
        }, 
        {
            "location": "/060_building_jobs_pipeline/#building-jobs-pipeline", 
            "text": "", 
            "title": "Building Jobs Pipeline"
        }, 
        {
            "location": "/060_building_jobs_pipeline/#creating-more-jobs-to-add-to-pipeline", 
            "text": "Lets create 2 more jobs so that we could connect those together to setup a mock build pipeline.  To create new jobs, you could click on create items, name the job and select the last option which says  Copy from Another Job .   For this tutorial, lets create jobs by name  job2  and  job3  which should be copies of job1.   At the end of this exercise, you should see 3 jobs listed on jenkins dashboard as above. While creating Job2 and Job3 for the first time, do not use any build triggers. We will update the configurations while defining upstream/downstream.", 
            "title": "Creating More Jobs to add to pipeline"
        }, 
        {
            "location": "/060_building_jobs_pipeline/#connecting-jobs", 
            "text": "Lets now create a pipeline by connecting these jobs together. We would create a pipeline with  job1 =  job2 =  job3  Where, job2 should run, only if job1 is built successfully, and should trigger job3 once it builds itself successfully. We could either define both  connections from job2, or go to job1 and job3 and define its relationship with job2.  We would do the later.  Lets open Job1 configurations and from  Post Build Actions  select  Build Other Projects  and select  job2 .   Lets also go to jobs3 and define a dependency on job2. To do so, you would have to scroll to  Build Triggers  section and select  Build after other projects are built  and provide job2.", 
            "title": "Connecting jobs"
        }, 
        {
            "location": "/060_building_jobs_pipeline/#upstreams-and-downstreams", 
            "text": "Jenkins calls these connections as  Upstreams  and  Downstreams . In the context of job1, its downstream is job2. And for job2, job1 is its upstream. Same goes with job2 and job3.  This is depicted in the following image which shows the job2 configurations.", 
            "title": "Upstreams and Downstreams"
        }, 
        {
            "location": "/060_building_jobs_pipeline/#install-pipeline-plugin", 
            "text": "To get a better view of the complete pipeline and the workflow, we would install a plugin which allows us to create a special view for connected jobs.  To install this plugin,    From  Manage Jenkins  select  Manage Plugins .    Click on  Available  tab and start typing \"pipeline\" int he filter box. No need to press enter.    Check the box against  Build Pipeline Plugin , the second option, and click on the button at the bottom to \"Download and install after restart\".    If you don't see this plugin in the  Available  list then check the  Installed  list to see if it is installed already.", 
            "title": "Install Pipeline Plugin"
        }, 
        {
            "location": "/060_building_jobs_pipeline/#crete-pipeline-view", 
            "text": "Lets now create a pipeline view.   From Jenkins dashboard click on the  +  symbol besides the current list view named  ALL  which displays all jobs.     Provide a name to the view e.g.  pipe1 , check the radio button for  Build Pipeline View . Click on ok.     From the view configurations, select initial job from the drop down menu and the number of displayed builds.  Click on OK to finish configurations and show the view.", 
            "title": "Crete Pipeline View"
        }, 
        {
            "location": "/060_building_jobs_pipeline/#run-pipelines", 
            "text": "The pipeline view reads the first job, and picks up all the jobs which are directly or indirectly connected showing you one single view of the complete workflow and the order in which it is going to be executed.      Pipeline view also shows the history of job runs up to the number of instances you selected earlier in the configurations.    Go trigger a  Run  from the pipeline view and see what happens. Make sure you have selected \"ENABLE AUTO REFRESH\" earlier from the top right corner of the screen.", 
            "title": "Run pipelines"
        }, 
        {
            "location": "/070_frontend/", 
            "text": "Build pipeline for Front End\n\n\nFront End pipeline contains two jobs.\n\n\n\n\nUnit Testing\n\n\nPackaging\n\n\n\n\n\n\nJob 1 (Unit Testing)\n\n\nThe purpose is to validate that each unit of the software performs as designed. unit testing successfully completed, Then the next step is packaging. Suppose unit testing failed, he doesn't perform packaging.\n\n\n\n\nSource Code Management\n\n\nThe Source Code is available at the github.com.\nYou need to clone it by following url\n\n\nhttps://github.com/microservices-demo/front-end.git\n\n\n\nIn Build Trigger we have select GitHub hook trigger for GITScm polling.\n\n\nWhatever is pushed to master i.e. github.com will immediately known by the  \nJenkins server\n.\n\n\n\n\n\n\nBuild Environment\n\n\nTo Build the environment we required \nNodeJS\n\n\n\n\nBuild\n\n\nTo Build the Environment we need to install the \nnpm\n you can install it by following Command.   \n\n\n\n\nJob 2 (Packaging)\n\n\nAfter the successful completion of validation then we go for packaging. After packaging we deploy the package to Artifactory.\n\n\n\n\nSource Code Management\n\n\nThe Source Code is available at the github.com.\nYou need to clone it by following url\n\n\nhttps://github.com/udbc/front-end.git/\n\n\n\nOnce the unit test successfully completed then packages are Triggered.\n\n\n\n\n\n\nBuild Environment\n\n\nBefore starting to build the environment we Delete workspace.\n\n\n\n\nArtifactory Configuration\n\n\nOnce the Unit test and Package are completed the we deploy these artifacts to Artifactory.\n\n\n\n\nTo download the Artifactory use the following url\n\n\nhttp://188.166.236.188.9081/artifactory\n\n\n\n\n\nBuild\n\n\nTo Build the Environment we need to install the \nnpm\n you can install it by following Command.   \n\n\n\n\nArtifactory\n\n\nOnce everything is done then the packages are deploy to Artifactory.", 
            "title": "Build Pipeline For Front-End"
        }, 
        {
            "location": "/070_frontend/#build-pipeline-for-front-end", 
            "text": "Front End pipeline contains two jobs.   Unit Testing  Packaging", 
            "title": "Build pipeline for Front End"
        }, 
        {
            "location": "/070_frontend/#job-1-unit-testing", 
            "text": "The purpose is to validate that each unit of the software performs as designed. unit testing successfully completed, Then the next step is packaging. Suppose unit testing failed, he doesn't perform packaging.", 
            "title": "Job 1 (Unit Testing)"
        }, 
        {
            "location": "/070_frontend/#source-code-management", 
            "text": "The Source Code is available at the github.com.\nYou need to clone it by following url  https://github.com/microservices-demo/front-end.git  In Build Trigger we have select GitHub hook trigger for GITScm polling.  Whatever is pushed to master i.e. github.com will immediately known by the   Jenkins server .", 
            "title": "Source Code Management"
        }, 
        {
            "location": "/070_frontend/#build-environment", 
            "text": "To Build the environment we required  NodeJS", 
            "title": "Build Environment"
        }, 
        {
            "location": "/070_frontend/#build", 
            "text": "To Build the Environment we need to install the  npm  you can install it by following Command.", 
            "title": "Build"
        }, 
        {
            "location": "/070_frontend/#job-2-packaging", 
            "text": "After the successful completion of validation then we go for packaging. After packaging we deploy the package to Artifactory.", 
            "title": "Job 2 (Packaging)"
        }, 
        {
            "location": "/070_frontend/#source-code-management_1", 
            "text": "The Source Code is available at the github.com.\nYou need to clone it by following url  https://github.com/udbc/front-end.git/  Once the unit test successfully completed then packages are Triggered.", 
            "title": "Source Code Management"
        }, 
        {
            "location": "/070_frontend/#build-environment_1", 
            "text": "Before starting to build the environment we Delete workspace.", 
            "title": "Build Environment"
        }, 
        {
            "location": "/070_frontend/#artifactory-configuration", 
            "text": "Once the Unit test and Package are completed the we deploy these artifacts to Artifactory.   To download the Artifactory use the following url  http://188.166.236.188.9081/artifactory", 
            "title": "Artifactory Configuration"
        }, 
        {
            "location": "/070_frontend/#build_1", 
            "text": "To Build the Environment we need to install the  npm  you can install it by following Command.", 
            "title": "Build"
        }, 
        {
            "location": "/070_frontend/#artifactory", 
            "text": "Once everything is done then the packages are deploy to Artifactory.", 
            "title": "Artifactory"
        }, 
        {
            "location": "/080_catalogue/", 
            "text": "Build pipeline for Catalogue\n\n\nCatalogue pipeline contains two jobs.\n\n\n\n\nUnit Testing\n\n\nPackaging\n\n\n\n\n \n\n\nJob 1 (Unit Testing)\n\n\nJenkins provides an out of box functionality for Junit, and provides a host of plugins for unit testing for other technologies. Unit test verify small block of code behaves as expected under a well-defined set of external conditions. Unit test aim to isolate the code under test. Once the unit testing is successful it goes to next job called packaging.\n\n\n \n\n\nGeneral\n\n\nthe source code of this available on the github.com\n\n\nuse the following link to download project.\n\n\ngit clone https://github.com/udbc/catalogue.git/\n\n\n\nSource Code Management\n\n\nTo get information related to source code management click on \nunit_test-catalogue\n and click on \nconfigure\n\n\nIn source code management we select option \nNone\n\n\n\n\n\n\nBuild Triggers\n\n\nIn \nBUILD TRIGGERS\n we select the option \nGithub hook trigger for GITScm polling\n . This option states that whatever is triggered or pushed to master i.e.  github.com will immediately know by the jenkins server .\n\n\n\n\nBuild\n\n\nIn \nBuild\n Execute shell script on remote host using \nssh\n\n\ncommand\n\n\nexport GOPATH=/opt/go\nexport path=\"/opt/go/bin:$PATH\"\ncd /tmp/\nrm -r *\ngit clone https://github.com/udbc/catalogue.git/\ncd catalogue/\ncp -r images/catalogue/tmp/images\ngvt restore\n\n\n\n\n\nPost Build Actions\n\n\nIf unit test build successfully completed. Its trigger to the package build. suppose unit test build failed. it doesn't trigger package build.\n\n\n\n\nJob 2 (Package catalogue)\n\n\nOnce the unit test build completed. It goes to package build.\n\n\n\n\nBuild Triggers\n\n\nIn \nBUILD TRIGGERS\n we select the option \nGithub hook trigger for GITScm polling\n . This option states that whatever is triggered or pushed to master i.e.  github.com will immediately know by the jenkins server .\n\n\n\n\nBuild\n\n\nOnce the Jenkins server gets triggered it start building the environment . It delete workspace before building the environment.\n\n\n\n\nOnce the packaging service is completed . We need to push the details of the package to the  Artifactory server with job configuration .\n\n\nspec:-\n{\n    \"files\": [\n        {\n            \"pattern\": \"app/(*).zip\",\n            \"target\": \"generic-local/catalogue/\",\n            \"recursive\": \"false\"\n        }\n    ]\n}\n\n\n\n\n\nIn \nBuild\n Execute shell script\n\n\necho \"Validating...\"\nwhich go\ngo version\nexport GOPATH=$WORKSPACE/opt/go\nexport PATH=\"$WORKSPACE/opt/go/bin:$PATH\"\n\necho \"Gopath:\" $GOPATH\necho \"Path:\" $PATH\n\necho \"Install gvt...\"\ngo get -u github.com/FiloSottile/gvt\n\necho \"I: Setup the repo...\"\nmkdir -p $WORKSPACE/opt/go/src/github.com/microservices-demo\ncd $WORKSPACE/opt/go/src/github.com/microservices-demo\ngit clone https://github.com/udbc/catalogue.git\n\necho \"I: Compile the code ...\"\ncd catalogue/\ncp -r images $WORKSPACE/images\ngvt restore\n\ncd cmd/cataloguesvc/\nCGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o $WORKSPACE/app/catalogue github.com/microservices-demo/catalogue/cmd/cataloguesvc\ncd $WORKSPACE/app/\nzip catalogue-$GIT_TAG_NAME.zip catalogue\n#mv catalogue-$GIT_TAG_NAME.zip /tmp/\n#tar -cvzf catalogue-$GIT_TAG_NAME.tar.gz catalogue\n\n\n\n\n\nArtifact Repository Browser\n\n\nOnce the packaging services deploy completed . To check artifact Repository Browser", 
            "title": "Build Pipeline For Catalogue"
        }, 
        {
            "location": "/080_catalogue/#build-pipeline-for-catalogue", 
            "text": "Catalogue pipeline contains two jobs.   Unit Testing  Packaging", 
            "title": "Build pipeline for Catalogue"
        }, 
        {
            "location": "/080_catalogue/#job-1-unit-testing", 
            "text": "Jenkins provides an out of box functionality for Junit, and provides a host of plugins for unit testing for other technologies. Unit test verify small block of code behaves as expected under a well-defined set of external conditions. Unit test aim to isolate the code under test. Once the unit testing is successful it goes to next job called packaging.", 
            "title": "Job 1 (Unit Testing)"
        }, 
        {
            "location": "/080_catalogue/#general", 
            "text": "the source code of this available on the github.com  use the following link to download project.  git clone https://github.com/udbc/catalogue.git/", 
            "title": "General"
        }, 
        {
            "location": "/080_catalogue/#source-code-management", 
            "text": "To get information related to source code management click on  unit_test-catalogue  and click on  configure  In source code management we select option  None", 
            "title": "Source Code Management"
        }, 
        {
            "location": "/080_catalogue/#build-triggers", 
            "text": "In  BUILD TRIGGERS  we select the option  Github hook trigger for GITScm polling  . This option states that whatever is triggered or pushed to master i.e.  github.com will immediately know by the jenkins server .", 
            "title": "Build Triggers"
        }, 
        {
            "location": "/080_catalogue/#build", 
            "text": "In  Build  Execute shell script on remote host using  ssh  command  export GOPATH=/opt/go\nexport path=\"/opt/go/bin:$PATH\"\ncd /tmp/\nrm -r *\ngit clone https://github.com/udbc/catalogue.git/\ncd catalogue/\ncp -r images/catalogue/tmp/images\ngvt restore", 
            "title": "Build"
        }, 
        {
            "location": "/080_catalogue/#post-build-actions", 
            "text": "If unit test build successfully completed. Its trigger to the package build. suppose unit test build failed. it doesn't trigger package build.", 
            "title": "Post Build Actions"
        }, 
        {
            "location": "/080_catalogue/#job-2-package-catalogue", 
            "text": "Once the unit test build completed. It goes to package build.", 
            "title": "Job 2 (Package catalogue)"
        }, 
        {
            "location": "/080_catalogue/#build-triggers_1", 
            "text": "In  BUILD TRIGGERS  we select the option  Github hook trigger for GITScm polling  . This option states that whatever is triggered or pushed to master i.e.  github.com will immediately know by the jenkins server .", 
            "title": "Build Triggers"
        }, 
        {
            "location": "/080_catalogue/#build_1", 
            "text": "Once the Jenkins server gets triggered it start building the environment . It delete workspace before building the environment.   Once the packaging service is completed . We need to push the details of the package to the  Artifactory server with job configuration .  spec:-\n{\n    \"files\": [\n        {\n            \"pattern\": \"app/(*).zip\",\n            \"target\": \"generic-local/catalogue/\",\n            \"recursive\": \"false\"\n        }\n    ]\n}   In  Build  Execute shell script  echo \"Validating...\"\nwhich go\ngo version\nexport GOPATH=$WORKSPACE/opt/go\nexport PATH=\"$WORKSPACE/opt/go/bin:$PATH\"\n\necho \"Gopath:\" $GOPATH\necho \"Path:\" $PATH\n\necho \"Install gvt...\"\ngo get -u github.com/FiloSottile/gvt\n\necho \"I: Setup the repo...\"\nmkdir -p $WORKSPACE/opt/go/src/github.com/microservices-demo\ncd $WORKSPACE/opt/go/src/github.com/microservices-demo\ngit clone https://github.com/udbc/catalogue.git\n\necho \"I: Compile the code ...\"\ncd catalogue/\ncp -r images $WORKSPACE/images\ngvt restore\n\ncd cmd/cataloguesvc/\nCGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o $WORKSPACE/app/catalogue github.com/microservices-demo/catalogue/cmd/cataloguesvc\ncd $WORKSPACE/app/\nzip catalogue-$GIT_TAG_NAME.zip catalogue\n#mv catalogue-$GIT_TAG_NAME.zip /tmp/\n#tar -cvzf catalogue-$GIT_TAG_NAME.tar.gz catalogue", 
            "title": "Build"
        }, 
        {
            "location": "/080_catalogue/#artifact-repository-browser", 
            "text": "Once the packaging services deploy completed . To check artifact Repository Browser", 
            "title": "Artifact Repository Browser"
        }, 
        {
            "location": "/090_carts/", 
            "text": "Build Pipeline for Cart\n\n\nPipeline for the Cart contains three jobs\n\n\n\n\nUnit Testing. \n\n\nComponent Testing\n\n\nPackages\n\n\n\n\n![BUILD PIPELINE](images/pipeline/BUILD PIPELINE.png)\n\n\nJob 1 (Unit testing)\n\n\nJenkins provides an out of box functionality for Junit, and provides a host of plugins for unit testing for other technologies. Unit tests verify that a small block of code behaves as expected under a well-defined set of external conditions. Unit tests aim to isolate the code under test.\n  Once the Unit testing is successful it goes to next job called \nComponent testing\n\n\n![Unit Testing](images/Job1/Unit test.png)\n\n\nGeneral\n\n\nThe source Code of this project will be available on the github.com.\n\n\nProject url:\n\n\n  https://github.com/udbc/carts.git/\n\n\n\n\n\nSource Code Management\n\n\nTo get the information related source code management click on the \nunit_test_carts\n and the click on \nconfigure\n\n\nIn Source Code Management we select the option \nNONE\n.\n\n\nIn \nBUILD TRIGGERS\n we select the option \nGitHub hook trigger for GITScm polling\n . This option states that whatever is triggered or pushed to the master i.e. github.com will immediately known by the jenkins server .\n\n\n\n\nBuild Enviornment\n\n\nOnce the Jenkins server gets triggered it starts building the environment. It deletes the workspace before building the environment.\n\n\n\n\nBuild\n\n\nIn this we are actually \ncloning\n are project and \nrunning\n the unit test module.\n\n\n\n\nJob 2 (Component Testing)\n\n\nIntegration tests exercise the interactions between different components of a system. Once the component test is passed successfully it move to \nPackages\n\n\n![Component testing](images/Job2/Component test.png)\n\n\nSource Code Management\n\n\nTo get the information related source code management click on the \ncomponent_test_carts\n and the click on \nconfigure\n\n\nIn Source Code Management we select the option \nNONE\n.\n\n\nIn \nBUILD TRIGGERS\n we select the option \nBuild after other projects are built\n . This option states that once the \nunit_test_cart\n is successfully done then only it can start the component testing.\n\n\n\n\nBuild Enviornment\n\n\nOnce the Jenkins server gets triggered it starts building the environment.\n\n\n\n\nBuild\n\n\nIn this we are actually \ncloning\n are project and \nrunning\n the component test module.\n\n\n\n\nPost-build Action\n\n\nIf the \nunit test\n and \ncomponent test\n is successfully done then only it is triggered to the package build.\n\n\n![Post](images/Job2/post component.png)\n\n\nJob 3 (Packages)\n\n\nOnce the Component test is passed it goes into the packages stage. The aim of packages is to depoly it to Artifactory.\n\n\n\n\nSource Code Management\n\n\nTo get the information related source code management click on the \npackage_carts\n and the click on \nconfigure\n\n\nIn Source Code Management we select the option \nGit\n. It states the are repository is present on github.com\n\n\nRepository url:-\n\n\nhttps://github.com/udbc/carts.git\n\n\n\n\n\nIn \nBUILD TRIGGERS\n we select the option \nGitHub hook trigger for GITScm polling\n. This option states that whatever is triggered or pushed to the master i.e. github.com will immediately known by the jenkins server .\n\n\n\n\nBuild\n\n\nTO build it successfully we have a file called \npom.xml\n in which the source is present. The main goal is to \nclean the compine package\n and to \nskip the testing part\n.\n\n\n\n\nPost-build Actions\n\n\nThis is the section where everything build earlier i.e. \nunit_test_cart\n and \ncomponent_test_carts\n artifacts are deployed to the \nArtifactory\n. Here we need to define the \ntarget release\n and \ntarget snapshot\n needed for the Artifactory.\n\n\n![PBA](images/Job3/PBA PACKAGE.png)\n\n\nARTIFACTORY :-\n\n\nThis is where you will be able to see that the cart module have been deployed to the \nArtifactory\n.", 
            "title": "Build Pipeline For Carts"
        }, 
        {
            "location": "/090_carts/#build-pipeline-for-cart", 
            "text": "Pipeline for the Cart contains three jobs   Unit Testing.   Component Testing  Packages   ![BUILD PIPELINE](images/pipeline/BUILD PIPELINE.png)", 
            "title": "Build Pipeline for Cart"
        }, 
        {
            "location": "/090_carts/#job-1-unit-testing", 
            "text": "Jenkins provides an out of box functionality for Junit, and provides a host of plugins for unit testing for other technologies. Unit tests verify that a small block of code behaves as expected under a well-defined set of external conditions. Unit tests aim to isolate the code under test.\n  Once the Unit testing is successful it goes to next job called  Component testing  ![Unit Testing](images/Job1/Unit test.png)", 
            "title": "Job 1 (Unit testing)"
        }, 
        {
            "location": "/090_carts/#general", 
            "text": "The source Code of this project will be available on the github.com.  Project url:    https://github.com/udbc/carts.git/", 
            "title": "General"
        }, 
        {
            "location": "/090_carts/#source-code-management", 
            "text": "To get the information related source code management click on the  unit_test_carts  and the click on  configure  In Source Code Management we select the option  NONE .  In  BUILD TRIGGERS  we select the option  GitHub hook trigger for GITScm polling  . This option states that whatever is triggered or pushed to the master i.e. github.com will immediately known by the jenkins server .", 
            "title": "Source Code Management"
        }, 
        {
            "location": "/090_carts/#build-enviornment", 
            "text": "Once the Jenkins server gets triggered it starts building the environment. It deletes the workspace before building the environment.", 
            "title": "Build Enviornment"
        }, 
        {
            "location": "/090_carts/#build", 
            "text": "In this we are actually  cloning  are project and  running  the unit test module.", 
            "title": "Build"
        }, 
        {
            "location": "/090_carts/#job-2-component-testing", 
            "text": "Integration tests exercise the interactions between different components of a system. Once the component test is passed successfully it move to  Packages  ![Component testing](images/Job2/Component test.png)", 
            "title": "Job 2 (Component Testing)"
        }, 
        {
            "location": "/090_carts/#source-code-management_1", 
            "text": "To get the information related source code management click on the  component_test_carts  and the click on  configure  In Source Code Management we select the option  NONE .  In  BUILD TRIGGERS  we select the option  Build after other projects are built  . This option states that once the  unit_test_cart  is successfully done then only it can start the component testing.", 
            "title": "Source Code Management"
        }, 
        {
            "location": "/090_carts/#build-enviornment_1", 
            "text": "Once the Jenkins server gets triggered it starts building the environment.", 
            "title": "Build Enviornment"
        }, 
        {
            "location": "/090_carts/#build_1", 
            "text": "In this we are actually  cloning  are project and  running  the component test module.", 
            "title": "Build"
        }, 
        {
            "location": "/090_carts/#post-build-action", 
            "text": "If the  unit test  and  component test  is successfully done then only it is triggered to the package build.  ![Post](images/Job2/post component.png)", 
            "title": "Post-build Action"
        }, 
        {
            "location": "/090_carts/#job-3-packages", 
            "text": "Once the Component test is passed it goes into the packages stage. The aim of packages is to depoly it to Artifactory.", 
            "title": "Job 3 (Packages)"
        }, 
        {
            "location": "/090_carts/#source-code-management_2", 
            "text": "To get the information related source code management click on the  package_carts  and the click on  configure  In Source Code Management we select the option  Git . It states the are repository is present on github.com  Repository url:-  https://github.com/udbc/carts.git   In  BUILD TRIGGERS  we select the option  GitHub hook trigger for GITScm polling . This option states that whatever is triggered or pushed to the master i.e. github.com will immediately known by the jenkins server .", 
            "title": "Source Code Management"
        }, 
        {
            "location": "/090_carts/#build_2", 
            "text": "TO build it successfully we have a file called  pom.xml  in which the source is present. The main goal is to  clean the compine package  and to  skip the testing part .", 
            "title": "Build"
        }, 
        {
            "location": "/090_carts/#post-build-actions", 
            "text": "This is the section where everything build earlier i.e.  unit_test_cart  and  component_test_carts  artifacts are deployed to the  Artifactory . Here we need to define the  target release  and  target snapshot  needed for the Artifactory.  ![PBA](images/Job3/PBA PACKAGE.png)", 
            "title": "Post-build Actions"
        }, 
        {
            "location": "/090_carts/#artifactory-", 
            "text": "This is where you will be able to see that the cart module have been deployed to the  Artifactory .", 
            "title": "ARTIFACTORY :-"
        }
    ]
}